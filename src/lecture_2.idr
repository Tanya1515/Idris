module Lecture_2

Public export
data Engine = Diesel | Gasoline | LPG
Namespace Example2 = Car Color Engine Transmission 

--пусть есть тип Vehicle  и способ создания его элементов (конструктор) Carб которому для создания значений типа Vehicle  требуется тройка значений: Color, Engine, Transmission

--У типа может быть несколько конструкторов Car = имя конструктора 
public export 
data Vehicle = Car Color Engine Transmission | Plane Color

--система типов устроена таким образом, что одно значение не может принадлежать разным типам. Все конструкторы разные. Типы = непересекающиеся подмножества 
--Как работать со значениями: имя : тип 
newCar : Vehicle 
newCar = Car Red Gasoline Automatic 

oldCar : Vehicle 
oldCar = Car Green Diesel Manual 

myCar : Vehicle 
myCar = oldCar 

--= - не присваивание, а связывание. myCar = newCar - работать не будет, поскольку myCar уже связано с oldCar 
--Аксиоматическое задание натуральных чисел: 
-- 1) Существует 0 - натуральное число 
-- 2) Если n - натуральное число, то существует следующее за ним натуральное число
-- 3) 0 не следует ни за каким натуральным числом 
-- 4) Если натуральное число а непосредственно следует как за числом b, так и за числом с,  то b и c тождественны 
-- 5) (Аксиома индукции) Если какое-либо предположение доказано для 1 (база индукции) и если из допущения, что оно верно для следующего за n натурального числа n, вытекает, что оно верно для следующего n натурального числа… 
-- Задали множество натуральных чисел
Namespace Prelude 
	data Nat = Z | S Nat 

--Определить константы Zero, One, Two типа Nat соответствующего значения 
Zero : Nat 
Zero = Z 
One : Nat 
One = S Z
Two : Nat 
Two = S One  //Или S (S Z)

--Объявление функционального типа 
--Prelude.S : Nat -> Nat 
-- D -> R - типа параметра -> тип результата 

-- Лямбда -выражение -  анонимная функция, выражение функционального типа. Пример: 
 inc’ : Nat -> Nat
 inc’ = \n (имя) => S n (выражение, в котором имя встречается)
--Синтаксический сахар: 
 inc : Nat -> Nat 
 inc n = S n

Namespace Prelude 
	partial -- - на каких-то значениях входного параметра функция возвращает результат 
	covering -- - с левой части от равенств перечислены все случаи параметров
	total -- - проверяются значения входных и выходных параметров  (проверяет корректность рекурсии - отсутствие зацикливания)
	
not: Bool -> Bool 
not True = False 
not False = True

--Пример функции, которая будет зацикливаться 
Covering 
	inf : Nat -> Nat 
	inf n = inf n

%default total -- - все функции по умолчанию объявляются тотальными, то есть проверяются на отсутствие зацикливания 

isZero : Nat -> Bool 
isZero Z = True 
isZero _ = False

-- isEven - функция, которая возвращает true, если число четное, false - если число нечетное 
isEven : Nat -> Bool 
IsEven Z = True 
IsEven (S Z) = False 
isEven ( S ( S n ) )  = isEven n

-- можно не рассматривать функцию с единицей
isEven : Nat -> Bool 
isEven Z = True 
isEven (S n) = not (isEven n) 

-- Функция, возвращающая остаток при делении на 3 
Mod_3 : Nat -> Nat  
Mod_3 Z = Z
Mod_3 (S Z) = (S Z)
Mod_3 (S (S Z)) = (S (S Z))
Mod_3 (S (S (S n))) = Mod_3 n

-- Другое решение: ($ - применение выражения слева к выражению справа)
Mod_3 : Nat -> Nat  
Mod_3 Z = 0
Mod_3 (S Z) = 1
Mod_3 (S (S Z)) = 2
Mod_3 $ S $ S $ n = Mod_3 n

-- Сигнатуры функций, которые добавляют константу к числу
add0 : Nat -> Nat 
add1 : Nat -> Nat …

-- Вместо того, чтобы определить каждую из этих функций вручную, можно определить функцию фабрику, которая будет генерит эти функции
add ‘ ’ : Nat -> (Nat -> Nat) 
add ‘ ’ m = \n => case m of 
			Z => n 
			S m’ => add ’ ’  m’ (S n)

-- Синтаксический сахар: 
add : Nat -> (Nat -> Nat)
add m n = case m of 
			Z => n 
			S m’ => add m (S n)

-- Можно избавиться от скобок 
add : Nat -> Nat -> Nat 
add Z n = n 
add (S m) n = add m (S n)

-- Частичное применение - возможность зафиксировать часть аргументов многоместной функции и создать другую функцию, меньшей арности 
-- Функция перемножения чисел 
mul : Nat -> Nat -> Nat 
mul Z n = Z 
mul (S m) n = add (mul m n) n

-- Инфиксная нотация - добавление ‘’: x = 5 ‘add’ 7
-- Если будет некоторое булонское выражение и два выражения неопределенного типа 
if : Bool -> t -> t -> t  
If True tn el = el 
If False tn el = tn 
